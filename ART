"""
===================================================================================
Mimic of a method called ART(Automatic Registraiton Toolbox).

Comments:

    Similarity measure uses zero-means cross-correlation but with absolute.

    Calculating time:
        The main differences compared to the older versions are that feature vectors are defined first to eliminate creating the same vectors and swiching algorithm used to deform images from Nearest Neighbor considering all points all the time to built-in method.
        2d: 4 seconds with scales = [16,8,4,2,1] ant the other default settings
            8 seconds with the same conditions as above but search_ranges = 2
        3d:
            1121 seconds (about 20 minutes) with scales = [12, 8, 4, 2, 1] and the rest are the default settings.
            about 3 minutes with scales = [16, 8, 4, 2] (also with [12, 10, 8, 6, 4, 2]) and the other default settings.
            calculating vec_field takes 2 minutes.

            scales = [12,8,4,2]
            search_ranges = 2
            feature_ranges = 2
            608.8s

            scales[4,3,2,1]
            cross_correlation: 784s
            find_vec_field: 562s
            method dot of numpy ndarray objects: 494s
            feature_vec_mat: 53s


    Improvements:

        multi-resolution strategy: feature_vector consisting of points not in contact with each other

===================================================================================
"""


import numpy as np
import nibabel as nib
from scipy.ndimage.filters import gaussian_filter
from scipy.ndimage import geometric_transform
from scipy.interpolate import RegularGridInterpolator
from scipy.signal import convolve

class ART2d:
    def __init__(self, scales, search_ranges=None, feature_ranges=None, gauss=3., full_multi_grid=False):
        if full_multi_grid is False:
            self.scales = scales
        else:
            self.scales = [scales[i] for j in xrange(1, len(scales)) for i in range(j+1)+range(j-1,0,-1)] + scales
        self.sranges = [2 for x in self.scales] if search_ranges is None else search_ranges
        self.franges = [2 for x in self.scales] if feature_ranges is None else feature_ranges
        self.dimension = 2
        self.gauss = gauss

    def load(self, filename):
        img = nib.load(filename)
        data = img.get_data()
        return data

    def save(self, filename):
        from os.path import splitext
        name, ext = splitext(filename)
        if not ext:
            ext = '.nii'
        nib.save(nib.Nifti1Image(self.deformed_spaces[-1] - self.deformed_spaces[0], np.identity(4)), name + '_warp' + ext)

    def show(self, ratio=10):
        import matplotlib.pyplot as plt
        for (img, space) in zip(self.results, self.deformed_spaces):
            plt.subplot(1,2,1)
            plt.imshow(img, cmap='gray')

            plt.subplot(1,2,2)
            plt.xlim(0, self.shape[1])
            plt.ylim(0, self.shape[0])
            ax = plt.gca()
            ax.invert_yaxis()
            for x in xrange(0, self.shape[0], ratio):
                plt.plot(space[x,:,1], space[x,:,0], 'k')
            for y in xrange(0, self.shape[1], ratio):
                plt.plot(space[:,y,1], space[:,y,0], 'k')
            plt.show()
        plt.subplot(1,2,1)
        plt.imshow(self.fixed, cmap='gray')
        plt.subplot(1,2,2)
        plt.imshow(self.results[0], cmap='gray')
        plt.show()

    def animation(self):
        import matplotlib
        matplotlib.use('TkAgg')
        from matplotlib.animation import ArtistAnimation
        import matplotlib.pyplot as plt
        fig = plt.figure()
        frames = []
        for result in self.results:
            img = plt.imshow(result, cmap='gray', origin='upper')
            frames.append([img])
        fixed_img = plt.imshow(self.fixed, cmap='gray', origin='upper')
        frames.append([fixed_img])
        ani = ArtistAnimation(fig, frames, interval=500, repeat_delay=1000)
        plt.show()

    def setFixed(self, filename):
        self.fixed = self.load(filename)
        if hasattr(self, 'results'):
            self.setShape()

    def setMoving(self, filename):
        self.results = np.array([self.load(filename)])
        if hasattr(self, 'fixed'):
            self.setShape()

    def setShape(self):
        if self.results[0].shape == self.fixed.shape:
            self.shape = self.fixed.shape
            self.deformed_spaces = np.array([np.mgrid[0:self.shape[0], 0:self.shape[1]].transpose(1,2,0).astype(np.float64)])
            self.vec_fields = np.array([np.zeros(self.shape + (self.dimension,))])
        else:
            raise ValueError('The shapes of the two images do not match each other.')

    # Something is wrong with this function, this function speeds up calc time but the result is not the same as the one using the function above.
    def find_vec_field_alt(self, data1, data2):
        import cv2

        down_sample1 = data1[::self.scale, ::self.scale]
        down_sample2 = data2[::self.scale, ::self.scale]

        bin1 = np.zeros([x + 2 * self.frange for x in down_sample1.shape], dtype=np.float32)
        bin2 = np.zeros([x + 2 * (self.srange + self.frange) for x in down_sample2.shape], dtype=np.float32)

        bin1[self.frange: - self.frange, self.frange: - self.frange] = down_sample1.astype(np.float32)
        bin2[self.srange+self.frange:-self.srange-self.frange, self.srange+self.frange:-self.srange-self.frange] = down_sample2.astype(np.float32)

        vec_field = np.zeros(down_sample1.shape + (2,))

        for i in xrange(down_sample1.shape[0]):
            for j in xrange(down_sample1.shape[1]):
                f1 = bin1[i: i + 2 * self.frange + 1, j: j + 2 * self.frange + 1]
                f2 = bin2[i: i + 2 * (self.frange + self.srange) + 1, j: j + 2 * (self.frange + self.srange) + 1]
                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(np.abs(cv2.matchTemplate(f2, f1, eval("cv2.TM_CCOEFF_NORMED"))))
                if min_val == max_val:
                    vec_field[i,j] = [0., 0.]
                else:
                    vec_field[i,j] = (np.array(max_loc[::-1]) - self.srange) * self.scale
        return vec_field

    def find_vec_field(self, data1, data2):

        import cv2

        bin1 = np.zeros([x + 2 * self.frange for x in self.shape], dtype=np.float32) + data1[0,0]
        bin2 = np.zeros([x + 2 * (self.srange * self.scale + self.frange) for x in self.shape], dtype=np.float32) + data2[0,0]

        bin1[self.frange: - self.frange, self.frange: - self.frange] = data1
        bin2[self.srange * self.scale + self.frange: - self.srange * self.scale - self.frange, self.srange * self.scale + self.frange: - self.srange * self.scale - self.frange] = data2

        xi = np.arange(0, self.shape[0], self.scale)
        yi = np.arange(0, self.shape[1], self.scale)

        vec_field = np.zeros((len(xi), len(yi), 2))

        for (i, x) in enumerate(xi):
            for (j, y) in enumerate(yi):
                f1 = bin1[x: x + 2 * self.frange + 1, y: y + 2 * self.frange + 1]
                f2 = bin2[x: x + 2 * (self.srange * self.scale + self.frange) + 1, y: y + 2 * (self.srange * self.scale + self.frange) + 1]
                simi_mat = np.abs(cv2.matchTemplate(f2, f1, cv2.TM_CCOEFF_NORMED)[::self.scale, ::self.scale])
                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(simi_mat)
                if min_val == max_val:
                    vec_field[i,j] = [0., 0.]
                else:
                    vec_field[i,j] = (np.array(max_loc[::-1]) - self.srange) * self.scale

        return vec_field

    def gaussian_bilinear_interp(self, vec_field):
        from scipy.interpolate import interp2d

        result = np.zeros(self.shape + (2,))

        for i in xrange(2):
            vec_field[:,:,i] = gaussian_filter(vec_field[:,:,i], self.gauss, mode='constant')

        xi = np.arange(0, vec_field.shape[0] * self.scale, self.scale)
        yi = np.arange(0, vec_field.shape[1] * self.scale, self.scale)

        x = np.arange(self.shape[0])
        y = np.arange(self.shape[1])

        for i in xrange(2):
            f = interp2d(yi, xi, vec_field[:,:,i])
            result[:,:,i] = f(y,x)

        return result

    def deformation_older(self, vec_field):

        def transform(coords):
            return tuple([coords[i] - vec_field[coords + (i,)] for i in xrange(self.dimension)])

        new_space = self.deformed_spaces[-1] + self.bilinear_interp_vf(vec_field, self.deformed_spaces[-1].reshape(-1, self.dimension))

        destination = geometric_transform(self.results[-1], transform)

        self.results = np.append(self.results, destination).reshape((len(self.results) + 1,) + self.shape)

        self.deformed_spaces = np.append(self.deformed_spaces, new_space).reshape((len(self.deformed_spaces) + 1,) + self.shape + (2,))

        self.vec_fields = np.append(self.vec_fields, vec_field).reshape((len(self.vec_fields) + 1,) + self.shape + (2,))

    def bilinear_interp_vf(self, vec_field, points):
        result = np.zeros(self.shape + (self.dimension,))
        x = np.arange(0, self.shape[0])
        y = np.arange(0, self.shape[1])

        for i in xrange(self.dimension):
            f = RegularGridInterpolator((x,y), vec_field[:,:,i], method='linear', bounds_error=False, fill_value=None)
            result[:,:,i] = f(points).reshape(self.shape)

        return result

    def deformation(self, vec_field):

        new_space = self.deformed_spaces[-1] + self.bilinear_interp_vf(vec_field, self.deformed_spaces[-1].reshape(-1,self.dimension))

        new_u = new_space - self.deformed_spaces[0]

        def transform(coords):
            return tuple([coords[i] - new_u[coords + (i,)] for i in xrange(2)])

        destination = geometric_transform(self.results[0], transform)

        self.results = np.append(self.results, destination).reshape((len(self.results) + 1,) + self.shape)

        self.deformed_spaces = np.append(self.deformed_spaces, new_space).reshape((len(self.deformed_spaces) + 1,) + self.shape + (2,))

        self.vec_fields = np.append(self.vec_fields, vec_field).reshape((len(self.vec_fields) + 1,) + self.shape + (2,))

    def run(self):

        for scale, srange, frange in zip(self.scales, self.sranges, self.franges):
            self.scale = scale
            self.srange = srange
            self.frange = frange
            print "scale", scale
            print "search_range", srange
            print "feature_range", frange

            """
            using gaussian filter
            000       @        @         @
            010  -->  @ 1/2.0/3.14/sigma @
            000       @        @         @
            """

            # apply gaussian filter for scaling
            g1 = gaussian_filter(self.results[-1], self.scale/2.0, mode='constant').astype(np.float32)
            g2 = gaussian_filter(self.fixed, self.scale/2.0, mode='constant').astype(np.float32)

            # estimate vector field from image g1 and g2 sparsely
            vf_sparse = self.find_vec_field(g1, g2)

            # apply gaussian filter and then bilinear interpolate vector field defined sparsely.
            vec_field_interp = self.gaussian_bilinear_interp(vf_sparse)

            # apply deformation to the current deformed space and image.
            self.deformation(vec_field_interp)

class ART3d:

    def __init__(self, scales, search_ranges=None, srange=2, feature_ranges=None, frange=2, sigma=3., full_multi_grid=False):
        if full_multi_grid is False:
            self.scales = scales
        else:
            self.scales = [scales[i] for j in xrange(1, len(scales)) for i in range(j+1)+range(j-1,0,-1)] + scales
        self.sranges = [srange for x in self.scales] if search_ranges is None else search_ranges
        self.franges = [frange for x in self.scales] if feature_ranges is None else feature_ranges
        self.sigma = sigma
        self.dimension = 3

    def load(self, filename):
        img = nib.load(filename)
        data = img.get_data()
        return data

    def save(self, filename):
        from os.path import splitext
        name, ext = splitext(filename)
        if not ext:
            ext = '.nii'
        nib.save(nib.Nifti1Image(self.results[-1], self.affine), name + '_result' + ext)
        # nib.save(nib.Nifti1Image(self.vec_fields, self.affine), name + '_vfs' + ext)
        nib.save(nib.Nifti1Image(self.displacement[-1], self.affine), name + '_warp' + ext)

    def setFixed(self, filename):
        img = nib.load(filename)
        data = img.get_data()
        self.fixed = data
        self.affine = img.get_affine()
        if hasattr(self, 'results'):
            self.setShape()

    def setMoving(self, filename):
        self.results = np.array([self.load(filename)])
        if hasattr(self, 'fixed'):
            self.setShape()

    def setShape(self):
        if self.results[0].shape == self.fixed.shape:
            self.shape = self.fixed.shape
            self.displacement = np.array([np.zeros(self.shape + (self.dimension,))])
            self.vec_fields = np.array([np.zeros(self.shape + (self.dimension,))])
            self.Id = np.mgrid[0:self.shape[0], 0:self.shape[1], 0:self.shape[2]].transpose(1,2,3,0)
        else:
            raise ValueError('The shapes of the two images do not match each other.')

    def find_vec_field(self, data1, data2):

        xi = np.arange(0, self.shape[0], self.scale)
        yi = np.arange(0, self.shape[1], self.scale)
        zi = np.arange(0, self.shape[2], self.scale)
        search = range(-self.srange, self.srange + 1)
        result = np.zeros((len(xi), len(yi),len(zi), 3))

        def inside(point):
            return (-1 < point[0] < self.shape[0]
                and -1 < point[1] < self.shape[1]
                and -1 < point[2] < self.shape[2])

        def feature_vec_mat(data):

            vecs = np.zeros((len(xi), len(yi), len(zi), self.window ** 3))

            temp = np.zeros([x + self.window - 1 for x in self.shape]) + data[0,0,0]

            temp[self.frange: - self.frange, self.frange: - self.frange, self.frange: -self.frange] = data

            for (i, x) in enumerate(xi):
                for (j, y) in enumerate(yi):
                    for (k, z) in enumerate(zi):
                        vecs[i,j,k] = temp[x: x + self.window, y: y + self.window, z: z + self.window].flatten()
                        # vecs[i,j,k] = vec - np.mean(vec)
            vecs = vecs - np.tile(np.mean(vecs, axis=3), (self.window ** 3, 1, 1, 1)).transpose(1,2,3,0)

            return vecs

        def cross_correlation(vec1, vec2):
            denom = vec2.dot(vec2)
            return 0 if denom == 0 else (vec1.dot(vec2) ** 2)/denom

        fvecs1 = feature_vec_mat(data1)
        fvecs2 = feature_vec_mat(data2)

        for (i, x) in enumerate(xi):
            for (j, y) in enumerate(yi):
                for (k, z) in enumerate(zi):

                    if (-1 < x - self.frange * self.scale and x + self.frange * self.scale < self.shape[0] and
                        -1 < y - self.frange * self.scale and y + self.frange * self.scale < self.shape[1] and
                        -1 < z - self.frange * self.scale and z + self.frange * self.scale < self.shape[2]):
                        # if search area falls in the image domain
                        similarities = [cross_correlation(fvecs1[i,j,k], fvecs2[i+l,j+m,k+n]) for l in search for m in search for n in search]
                    else:
                        # if search range goes beyond the boundary
                        similarities = [cross_correlation(fvecs1[i,j,k], fvecs2[i+l,j+m,k+n]) if (-1 < x+l*self.scale < self.shape[0] and -1 < y+m*self.scale < self.shape[1] and -1 < z+n*self.scale < self.shape[2]) else 0. for l in search for m in search for n in search]

                    if np.max(similarities) == similarities[(len(similarities)-1)/2]:
                        vec = [0.,0.,0.]
                    else:
                        vec = list(np.unravel_index(np.argmax(similarities), (2 * self.srange + 1, 2 * self.srange + 1, 2 * self.srange + 1)))
                        vec = [(v - self.srange) * self.scale for v in vec]
                    result[i,j,k] = vec
        return result

    def find_vec_field_alt(self, data1, data2):

        data1 = data1[::self.scale, ::self.scale, ::self.scale]
        data2 = data2[::self.scale, ::self.scale, ::self.scale]

        shape = data1.shape

        search = range(-self.srange, self.srange + 1)
        result = np.zeros(shape + (self.dimension,))

        def inside(point):
            return (-1 < point[0] < shape[0]
                and -1 < point[1] < shape[1]
                and -1 < point[2] < shape[2])

        def feature_vec_mat(data):

            vecs = np.zeros(shape + (self.window ** 3,))

            temp = np.zeros([x + self.window - 1 for x in shape])

            temp[self.frange: - self.frange, self.frange: - self.frange, self.frange: -self.frange] = data

            for i in xrange(shape[0]):
                for j in xrange(shape[1]):
                    for k in xrange(shape[2]):
                        vecs[i,j,k] = temp[i: i + self.window, j: j + self.window, k: k + self.window].flatten()
                        # vecs[i,j,k] = vec - np.mean(vec)
            vecs = vecs - np.tile(np.mean(vecs, axis=3), (self.window ** self.dimension, 1, 1, 1)).transpose(1,2,3,0)

            return vecs

        def cross_correlation(vec1, vec2):
            denom = vec2.dot(vec2)
            return 0 if denom == 0 else (vec1.dot(vec2) ** 2)/denom

        fvecs1 = feature_vec_mat(data1)
        fvecs2 = feature_vec_mat(data2)

        for i in xrange(shape[0]):
            for j in xrange(shape[1]):
                for k in xrange(shape[2]):

                    if (-1 < i - self.frange and i + self.frange < shape[0] and
                        -1 < j - self.frange and j + self.frange < shape[1] and
                        -1 < k - self.frange and k + self.frange < shape[2]):
                        # if search area falls in the image domain
                        similarities = [cross_correlation(fvecs1[i,j,k], fvecs2[i+l,j+m,k+n]) for l in search for m in search for n in search]
                    else:
                        # if search range goes beyond the boundary
                        similarities = [cross_correlation(fvecs1[i,j,k], fvecs2[i+l,j+m,k+n]) if (-1 < i+l < shape[0] and -1 < j+m < shape[1] and -1 < k+n < shape[2]) else 0. for l in search for m in search for n in search]

                    if np.max(similarities) == similarities[(len(similarities)-1)/2]:
                        vec = [0.,0.,0.]
                    else:
                        vec = list(np.unravel_index(np.argmax(similarities), (2 * self.srange + 1, 2 * self.srange + 1, 2 * self.srange + 1)))
                        vec = [(v - self.srange) * self.scale for v in vec]
                    result[i,j,k] = vec
        return result

    def gaussian_trilinear_interp(self, vec_field):

        result = np.zeros(self.shape + (3,))

        for i in xrange(3):
                vec_field[:,:,:,i] = gaussian_filter(vec_field[:,:,:,i], self.sigma, mode='constant')

        x = np.arange(0, vec_field.shape[0] * self.scale, self.scale)
        y = np.arange(0, vec_field.shape[1] * self.scale, self.scale)
        z = np.arange(0, vec_field.shape[2] * self.scale, self.scale)

        points = np.mgrid[0:self.shape[0], 0:self.shape[1], 0:self.shape[2]].transpose(1,2,3,0).reshape(-1,3)

        for i in xrange(3):
            f = RegularGridInterpolator((x,y,z), vec_field[:,:,:,i], method='linear', bounds_error=False, fill_value=None)
            result[:,:,:,i] = f(points).reshape(self.shape)

        return result

    def deformation_older(self, vec_field):
        from scipy.ndimage import geometric_transform

        def transform(coords):
            return tuple([coords[i] - vec_field[coords + (i,)] for i in xrange(self.dimension)])

        u_x = self.displacement[-1] + self.trilinear_interp_vf(vec_field, (self.displacement[-1] + self.Id).reshape(-1, self.dimension))

        destination = geometric_transform(self.results[-1], transform)

        self.results = np.append(self.results, destination).reshape((len(self.results) + 1,) + self.shape)

        if not hasattr(self, 'vec_field'):
            self.vec_fields = np.array([vec_field])
        else:
            self.vec_fields = np.append(self.vec_fields, vec_field).reshape((len(self.vec_fields) + 1,) + self.shape + (self.dimension,))

        self.displacement = np.append(self.displacement, u_x).reshape((len(self.displacement) + 1,) + self.shape + (self.dimension,))

    def trilinear_interp_vf(self, vec_field, points):
        result = np.zeros(self.shape + (self.dimension,))
        x = np.arange(0, self.shape[0])
        y = np.arange(0, self.shape[1])
        z = np.arange(0, self.shape[2])

        for i in xrange(self.dimension):
            f = RegularGridInterpolator((x,y,z), vec_field[:,:,:,i], method='linear', bounds_error=False, fill_value=None)
            result[:,:,:,i] = f(points).reshape(self.shape)

        return result

    def deformation(self, vec_field):
        from scipy.ndimage import geometric_transform

        u_x = self.displacement[-1] + self.trilinear_interp_vf(vec_field, (self.displacement[-1] + self.Id).reshape(-1, self.dimension))

        def transform(coords):
            return tuple([coords[i] - u_x[coords + (i,)] for i in xrange(3)])

        destination = geometric_transform(self.results[0], transform)

        self.results = np.append(self.results, destination).reshape((len(self.results) + 1,) + self.shape)

        self.vec_fields = np.append(self.vec_fields, vec_field).reshape((len(self.vec_fields) + 1,) + self.shape + (self.dimension,))

        self.displacement = np.append(self.displacement, u_x).reshape((len(self.displacement) + 1,) + self.shape + (self.dimension,))

    def run(self):
        from scipy.ndimage.filters import gaussian_filter

        for scale, srange, frange in zip(self.scales, self.sranges, self.franges):
            self.scale = scale
            self.srange = srange
            self.frange = frange
            self.window = 2 * frange + 1
            print "scale", scale
            print "search_range", srange
            print "feature_range", frange

            """
            using gaussian filter in 2d
            000       @        @         @
            010  -->  @ 1/2.0/3.14/sigma @
            000       @        @         @
            """

            g1 = gaussian_filter(self.results[-1], self.scale/2.0, mode='constant')
            g2 = gaussian_filter(self.fixed, self.scale/2.0, mode='constant')

            vf_sparse = self.find_vec_field_alt(g1, g2)

            vec_field_interp = self.gaussian_trilinear_interp(vf_sparse)

            self.deformation(vec_field_interp)


def main2():
    from os.path import abspath, join

    working_dir = abspath('/Users/admin/registration/img/myART_test2d')

    fixed_imgfile = join(working_dir, 'animalx_standard.nii')
    moving_imgfile = join(working_dir, 'animal2x_affine.nii')
    # result_imgfile = join(working_dir, 'xresult.nii')

    # for gaussian regularization and then bilinear interpolation
    # scales = [16,10, 8,6, 4, 2,1,1]

    scales = [16,10,8,6,4,2,1]
    test = ART2d(scales=scales)
    test.setFixed(fixed_imgfile)
    test.setMoving(moving_imgfile)
    test.run()
    # test.save(result_imgfile)
    # test.animation()
    # test.show()

def main3():
    from os.path import abspath, join

    working_dir = abspath('/Users/admin/registration/img/marmoset2/1506/warping_result')

    fixed_imgfile = join(working_dir, '7_invivo_b0_resized.nii')
    moving_imgfile = join(working_dir, '6_invivo_affine.nii')
    result_imgfile = join(working_dir, 'test.nii')

    scales = [4,3,2,1]
    reg = ART3d(scales)
    reg.setFixed(fixed_imgfile)
    reg.setMoving(moving_imgfile)
    reg.run()
    reg.save(result_imgfile)

if __name__ == '__main__':
    main3()
